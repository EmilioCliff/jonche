// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: customers.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addCustomerLoaned = `-- name: AddCustomerLoaned :exec
UPDATE customers
SET loaned = loaned + $1
WHERE id = $2
`

type AddCustomerLoanedParams struct {
	Loaned pgtype.Numeric `json:"loaned"`
	ID     int64          `json:"id"`
}

func (q *Queries) AddCustomerLoaned(ctx context.Context, arg AddCustomerLoanedParams) error {
	_, err := q.db.Exec(ctx, addCustomerLoaned, arg.Loaned, arg.ID)
	return err
}

const countCustomers = `-- name: CountCustomers :one
SELECT COUNT(*) AS total_customers FROM customers
`

func (q *Queries) CountCustomers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countCustomers)
	var total_customers int64
	err := row.Scan(&total_customers)
	return total_customers, err
}

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customers (
  name, phone_number
) VALUES (
  $1, $2
)
RETURNING id, name, phone_number, status, loaned, created_at
`

type CreateCustomerParams struct {
	Name        string `json:"name"`
	PhoneNumber string `json:"phone_number"`
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (Customer, error) {
	row := q.db.QueryRow(ctx, createCustomer, arg.Name, arg.PhoneNumber)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PhoneNumber,
		&i.Status,
		&i.Loaned,
		&i.CreatedAt,
	)
	return i, err
}

const deleteCustomer = `-- name: DeleteCustomer :exec
DELETE FROM customers WHERE id = $1
`

func (q *Queries) DeleteCustomer(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteCustomer, id)
	return err
}

const getCustomer = `-- name: GetCustomer :one
SELECT id, name, phone_number, status, loaned, created_at FROM customers
WHERE 
  (id = $1 OR phone_number = $2)
LIMIT 1
`

type GetCustomerParams struct {
	ID          pgtype.Int8 `json:"id"`
	PhoneNumber pgtype.Text `json:"phone_number"`
}

func (q *Queries) GetCustomer(ctx context.Context, arg GetCustomerParams) (Customer, error) {
	row := q.db.QueryRow(ctx, getCustomer, arg.ID, arg.PhoneNumber)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PhoneNumber,
		&i.Status,
		&i.Loaned,
		&i.CreatedAt,
	)
	return i, err
}

const getCustomerFullData = `-- name: GetCustomerFullData :one
WITH customer_data AS (
  SELECT customers.id, customers.name, customers.phone_number, customers.status, customers.loaned, customers.created_at FROM customers
  WHERE customers.id = $1
),
loans_paginated AS (
  SELECT id, customer_id, description, amount, created_at FROM loans 
  WHERE loans.customer_id = $1
  ORDER BY created_at DESC
  LIMIT $3 OFFSET $2
),
sms_paginated AS (
  SELECT id, customer_id, message, type, status, created_at, ref_id, cost, description, callback_status FROM sms 
  WHERE sms.customer_id = $1
  ORDER BY created_at DESC
  LIMIT $3 OFFSET $2
),
payments_paginated AS (
  SELECT id, transaction_number, transaction_source, paying_name, amount, assigned, assigned_to, paid_at FROM payments 
  WHERE payments.assigned_to = $1
  ORDER BY paid_at DESC
  LIMIT $3 OFFSET $2
),
loans_count AS (
  SELECT COUNT(*) AS total_loans FROM loans WHERE loans.customer_id = $1
),
sms_count AS (
  SELECT COUNT(*) AS total_sms FROM sms WHERE sms.customer_id = $1
),
payments_count AS (
  SELECT COUNT(*) AS total_payments FROM payments WHERE payments.assigned_to = $1
)
SELECT 
  (SELECT row_to_json(c) FROM (SELECT id, name, phone_number, status, loaned, created_at FROM customer_data) c) AS customer,
  (SELECT json_agg(l) FROM loans_paginated l) AS loans,
  (SELECT json_agg(s) FROM sms_paginated s) AS sms,
  (SELECT json_agg(p) FROM payments_paginated p) AS payments,
  (SELECT total_loans FROM loans_count) AS total_loans,
  (SELECT total_sms FROM sms_count) AS total_sms,
  (SELECT total_payments FROM payments_count) AS total_payments
`

type GetCustomerFullDataParams struct {
	ID     int64 `json:"id"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

type GetCustomerFullDataRow struct {
	Customer      []byte `json:"customer"`
	Loans         []byte `json:"loans"`
	Sms           []byte `json:"sms"`
	Payments      []byte `json:"payments"`
	TotalLoans    int64  `json:"total_loans"`
	TotalSms      int64  `json:"total_sms"`
	TotalPayments int64  `json:"total_payments"`
}

func (q *Queries) GetCustomerFullData(ctx context.Context, arg GetCustomerFullDataParams) (GetCustomerFullDataRow, error) {
	row := q.db.QueryRow(ctx, getCustomerFullData, arg.ID, arg.Offset, arg.Limit)
	var i GetCustomerFullDataRow
	err := row.Scan(
		&i.Customer,
		&i.Loans,
		&i.Sms,
		&i.Payments,
		&i.TotalLoans,
		&i.TotalSms,
		&i.TotalPayments,
	)
	return i, err
}

const getCustomerIDByName = `-- name: GetCustomerIDByName :one
SELECT id FROM customers 
WHERE name = $1
LIMIT 1
`

func (q *Queries) GetCustomerIDByName(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRow(ctx, getCustomerIDByName, name)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getCustomerList = `-- name: GetCustomerList :many
SELECT id, name, phone_number FROM customers
ORDER BY created_at DESC
`

type GetCustomerListRow struct {
	ID          int64  `json:"id"`
	Name        string `json:"name"`
	PhoneNumber string `json:"phone_number"`
}

func (q *Queries) GetCustomerList(ctx context.Context) ([]GetCustomerListRow, error) {
	rows, err := q.db.Query(ctx, getCustomerList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCustomerListRow{}
	for rows.Next() {
		var i GetCustomerListRow
		if err := rows.Scan(&i.ID, &i.Name, &i.PhoneNumber); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCustomers = `-- name: ListCustomers :many
SELECT id, name, phone_number, status, loaned, created_at FROM customers
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListCustomersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListCustomers(ctx context.Context, arg ListCustomersParams) ([]Customer, error) {
	rows, err := q.db.Query(ctx, listCustomers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Customer{}
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PhoneNumber,
			&i.Status,
			&i.Loaned,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reduceCustomerLoaned = `-- name: ReduceCustomerLoaned :one
UPDATE customers
SET loaned = loaned - $1
WHERE id = $2
RETURNING id, name, phone_number, status, loaned, created_at
`

type ReduceCustomerLoanedParams struct {
	Loaned pgtype.Numeric `json:"loaned"`
	ID     int64          `json:"id"`
}

func (q *Queries) ReduceCustomerLoaned(ctx context.Context, arg ReduceCustomerLoanedParams) (Customer, error) {
	row := q.db.QueryRow(ctx, reduceCustomerLoaned, arg.Loaned, arg.ID)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PhoneNumber,
		&i.Status,
		&i.Loaned,
		&i.CreatedAt,
	)
	return i, err
}

const updateCustomer = `-- name: UpdateCustomer :one
UPDATE customers
SET name = coalesce($1, name),
    phone_number = coalesce($2, phone_number),
    status = coalesce($3, status)
WHERE id = $4
RETURNING id, name, phone_number, status, loaned, created_at
`

type UpdateCustomerParams struct {
	Name        pgtype.Text `json:"name"`
	PhoneNumber pgtype.Text `json:"phone_number"`
	Status      pgtype.Bool `json:"status"`
	ID          int64       `json:"id"`
}

func (q *Queries) UpdateCustomer(ctx context.Context, arg UpdateCustomerParams) (Customer, error) {
	row := q.db.QueryRow(ctx, updateCustomer,
		arg.Name,
		arg.PhoneNumber,
		arg.Status,
		arg.ID,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PhoneNumber,
		&i.Status,
		&i.Loaned,
		&i.CreatedAt,
	)
	return i, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: payments.sql

package generated

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignPayment = `-- name: AssignPayment :one
UPDATE payments
SET assigned = true,
    assigned_to = $1
WHERE id = $2
RETURNING id, transaction_number, transaction_source, paying_name, amount, assigned, assigned_to, paid_at
`

type AssignPaymentParams struct {
	AssignedTo pgtype.Int8 `json:"assigned_to"`
	ID         int64       `json:"id"`
}

func (q *Queries) AssignPayment(ctx context.Context, arg AssignPaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, assignPayment, arg.AssignedTo, arg.ID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.TransactionNumber,
		&i.TransactionSource,
		&i.PayingName,
		&i.Amount,
		&i.Assigned,
		&i.AssignedTo,
		&i.PaidAt,
	)
	return i, err
}

const checkPaymentAssigned = `-- name: CheckPaymentAssigned :one
SELECT 
  CASE 
    WHEN assigned = TRUE THEN TRUE 
    ELSE FALSE 
  END AS is_assigned
FROM payments
WHERE id = $1
`

func (q *Queries) CheckPaymentAssigned(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRow(ctx, checkPaymentAssigned, id)
	var is_assigned bool
	err := row.Scan(&is_assigned)
	return is_assigned, err
}

const countCustomerPayments = `-- name: CountCustomerPayments :one
SELECT COUNT(*) AS total_payments FROM payments WHERE assigned_to = $1
`

func (q *Queries) CountCustomerPayments(ctx context.Context, assignedTo pgtype.Int8) (int64, error) {
	row := q.db.QueryRow(ctx, countCustomerPayments, assignedTo)
	var total_payments int64
	err := row.Scan(&total_payments)
	return total_payments, err
}

const countPayments = `-- name: CountPayments :one
SELECT COUNT(*) AS total_payments FROM payments
WHERE paid_at BETWEEN $1 AND $2
`

type CountPaymentsParams struct {
	StartDate time.Time `json:"start_date"`
	EndDate   time.Time `json:"end_date"`
}

func (q *Queries) CountPayments(ctx context.Context, arg CountPaymentsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPayments, arg.StartDate, arg.EndDate)
	var total_payments int64
	err := row.Scan(&total_payments)
	return total_payments, err
}

const createPayment = `-- name: CreatePayment :one
INSERT INTO payments (
    transaction_number, transaction_source, paying_name, amount, assigned, assigned_to, paid_at
) VALUES (
    $1, $2, $3, $4, $5, COALESCE($6, 0), $7
)
RETURNING id, transaction_number, transaction_source, paying_name, amount, assigned, assigned_to, paid_at
`

type CreatePaymentParams struct {
	TransactionNumber string         `json:"transaction_number"`
	TransactionSource string         `json:"transaction_source"`
	PayingName        string         `json:"paying_name"`
	Amount            pgtype.Numeric `json:"amount"`
	Assigned          bool           `json:"assigned"`
	AssignedTo        interface{}    `json:"assigned_to"`
	PaidAt            time.Time      `json:"paid_at"`
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, createPayment,
		arg.TransactionNumber,
		arg.TransactionSource,
		arg.PayingName,
		arg.Amount,
		arg.Assigned,
		arg.AssignedTo,
		arg.PaidAt,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.TransactionNumber,
		&i.TransactionSource,
		&i.PayingName,
		&i.Amount,
		&i.Assigned,
		&i.AssignedTo,
		&i.PaidAt,
	)
	return i, err
}

const getPayment = `-- name: GetPayment :one
SELECT 
    payments.id, payments.transaction_number, payments.transaction_source, payments.paying_name, payments.amount, payments.assigned, payments.assigned_to, payments.paid_at, 
    CASE 
        WHEN payments.assigned = TRUE THEN customers.name 
        ELSE NULL 
    END AS customer_name,
    CASE 
        WHEN payments.assigned = TRUE THEN customers.phone_number 
        ELSE NULL 
    END AS customer_phone_number
FROM payments
LEFT JOIN customers ON customers.id = payments.assigned_to
WHERE payments.id = $1
ORDER BY payments.paid_at DESC
`

type GetPaymentRow struct {
	ID                  int64          `json:"id"`
	TransactionNumber   string         `json:"transaction_number"`
	TransactionSource   string         `json:"transaction_source"`
	PayingName          string         `json:"paying_name"`
	Amount              pgtype.Numeric `json:"amount"`
	Assigned            bool           `json:"assigned"`
	AssignedTo          pgtype.Int8    `json:"assigned_to"`
	PaidAt              time.Time      `json:"paid_at"`
	CustomerName        interface{}    `json:"customer_name"`
	CustomerPhoneNumber interface{}    `json:"customer_phone_number"`
}

func (q *Queries) GetPayment(ctx context.Context, id int64) (GetPaymentRow, error) {
	row := q.db.QueryRow(ctx, getPayment, id)
	var i GetPaymentRow
	err := row.Scan(
		&i.ID,
		&i.TransactionNumber,
		&i.TransactionSource,
		&i.PayingName,
		&i.Amount,
		&i.Assigned,
		&i.AssignedTo,
		&i.PaidAt,
		&i.CustomerName,
		&i.CustomerPhoneNumber,
	)
	return i, err
}

const listCustomerPayments = `-- name: ListCustomerPayments :many
SELECT 
    payments.id, payments.transaction_number, payments.transaction_source, payments.paying_name, payments.amount, payments.assigned, payments.assigned_to, payments.paid_at, 
    customers.name AS customer_name,
    customers.phone_number AS customer_phone_number
FROM payments
LEFT JOIN customers ON customers.id = payments.assigned_to
WHERE payments.assigned_to = $1
ORDER BY payments.paid_at DESC
LIMIT $3 OFFSET $2
`

type ListCustomerPaymentsParams struct {
	CustomerID pgtype.Int8 `json:"customer_id"`
	Offset     int32       `json:"offset"`
	Limit      int32       `json:"limit"`
}

type ListCustomerPaymentsRow struct {
	ID                  int64          `json:"id"`
	TransactionNumber   string         `json:"transaction_number"`
	TransactionSource   string         `json:"transaction_source"`
	PayingName          string         `json:"paying_name"`
	Amount              pgtype.Numeric `json:"amount"`
	Assigned            bool           `json:"assigned"`
	AssignedTo          pgtype.Int8    `json:"assigned_to"`
	PaidAt              time.Time      `json:"paid_at"`
	CustomerName        pgtype.Text    `json:"customer_name"`
	CustomerPhoneNumber pgtype.Text    `json:"customer_phone_number"`
}

func (q *Queries) ListCustomerPayments(ctx context.Context, arg ListCustomerPaymentsParams) ([]ListCustomerPaymentsRow, error) {
	rows, err := q.db.Query(ctx, listCustomerPayments, arg.CustomerID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCustomerPaymentsRow{}
	for rows.Next() {
		var i ListCustomerPaymentsRow
		if err := rows.Scan(
			&i.ID,
			&i.TransactionNumber,
			&i.TransactionSource,
			&i.PayingName,
			&i.Amount,
			&i.Assigned,
			&i.AssignedTo,
			&i.PaidAt,
			&i.CustomerName,
			&i.CustomerPhoneNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPayments = `-- name: ListPayments :many
SELECT 
    payments.id, payments.transaction_number, payments.transaction_source, payments.paying_name, payments.amount, payments.assigned, payments.assigned_to, payments.paid_at, 
    CASE 
        WHEN payments.assigned = TRUE THEN customers.name 
        ELSE NULL 
    END AS customer_name,
    CASE 
        WHEN payments.assigned = TRUE THEN customers.phone_number 
        ELSE NULL 
    END AS customer_phone_number
FROM payments
LEFT JOIN customers ON customers.id = payments.assigned_to
WHERE payments.paid_at BETWEEN $1 AND $2
ORDER BY payments.paid_at DESC
LIMIT $4 OFFSET $3
`

type ListPaymentsParams struct {
	StartDate time.Time `json:"start_date"`
	EndDate   time.Time `json:"end_date"`
	Offset    int32     `json:"offset"`
	Limit     int32     `json:"limit"`
}

type ListPaymentsRow struct {
	ID                  int64          `json:"id"`
	TransactionNumber   string         `json:"transaction_number"`
	TransactionSource   string         `json:"transaction_source"`
	PayingName          string         `json:"paying_name"`
	Amount              pgtype.Numeric `json:"amount"`
	Assigned            bool           `json:"assigned"`
	AssignedTo          pgtype.Int8    `json:"assigned_to"`
	PaidAt              time.Time      `json:"paid_at"`
	CustomerName        interface{}    `json:"customer_name"`
	CustomerPhoneNumber interface{}    `json:"customer_phone_number"`
}

func (q *Queries) ListPayments(ctx context.Context, arg ListPaymentsParams) ([]ListPaymentsRow, error) {
	rows, err := q.db.Query(ctx, listPayments,
		arg.StartDate,
		arg.EndDate,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPaymentsRow{}
	for rows.Next() {
		var i ListPaymentsRow
		if err := rows.Scan(
			&i.ID,
			&i.TransactionNumber,
			&i.TransactionSource,
			&i.PayingName,
			&i.Amount,
			&i.Assigned,
			&i.AssignedTo,
			&i.PaidAt,
			&i.CustomerName,
			&i.CustomerPhoneNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

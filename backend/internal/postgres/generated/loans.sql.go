// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: loans.sql

package generated

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countCustomerLoans = `-- name: CountCustomerLoans :one
SELECT COUNT(*) AS total_loans FROM loans WHERE customer_id = $1
`

func (q *Queries) CountCustomerLoans(ctx context.Context, customerID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countCustomerLoans, customerID)
	var total_loans int64
	err := row.Scan(&total_loans)
	return total_loans, err
}

const countLoans = `-- name: CountLoans :one
SELECT COUNT(*) AS total_loans FROM loans
`

func (q *Queries) CountLoans(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countLoans)
	var total_loans int64
	err := row.Scan(&total_loans)
	return total_loans, err
}

const createLoan = `-- name: CreateLoan :one
INSERT INTO loans (
    customer_id, description, amount
) VALUES (
    $1, $2, $3
)
RETURNING id, customer_id, description, amount, created_at
`

type CreateLoanParams struct {
	CustomerID  int64          `json:"customer_id"`
	Description string         `json:"description"`
	Amount      pgtype.Numeric `json:"amount"`
}

func (q *Queries) CreateLoan(ctx context.Context, arg CreateLoanParams) (Loan, error) {
	row := q.db.QueryRow(ctx, createLoan, arg.CustomerID, arg.Description, arg.Amount)
	var i Loan
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Description,
		&i.Amount,
		&i.CreatedAt,
	)
	return i, err
}

const deleteLoan = `-- name: DeleteLoan :exec
DELETE FROM loans WHERE id = $1
`

func (q *Queries) DeleteLoan(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteLoan, id)
	return err
}

const getLoan = `-- name: GetLoan :one
SELECT
    loans.id, loans.customer_id, loans.description, loans.amount, loans.created_at,
    customers.name AS customer_name, 
    customers.phone_number AS customer_phone_number
FROM loans
JOIN customers ON customers.id = loans.customer_id
WHERE loans.id = $1
ORDER BY loans.created_at DESC
`

type GetLoanRow struct {
	ID                  int64          `json:"id"`
	CustomerID          int64          `json:"customer_id"`
	Description         string         `json:"description"`
	Amount              pgtype.Numeric `json:"amount"`
	CreatedAt           time.Time      `json:"created_at"`
	CustomerName        string         `json:"customer_name"`
	CustomerPhoneNumber string         `json:"customer_phone_number"`
}

func (q *Queries) GetLoan(ctx context.Context, id int64) (GetLoanRow, error) {
	row := q.db.QueryRow(ctx, getLoan, id)
	var i GetLoanRow
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Description,
		&i.Amount,
		&i.CreatedAt,
		&i.CustomerName,
		&i.CustomerPhoneNumber,
	)
	return i, err
}

const listCustomerLoans = `-- name: ListCustomerLoans :many
SELECT 
  loans.id, loans.customer_id, loans.description, loans.amount, loans.created_at, 
  customers.name AS customer_name, 
  customers.phone_number AS customer_phone_number
FROM loans
JOIN customers ON customers.id = loans.customer_id
WHERE loans.customer_id = $1
ORDER BY loans.created_at DESC
LIMIT $3 OFFSET $2
`

type ListCustomerLoansParams struct {
	CustomerID int64 `json:"customer_id"`
	Offset     int32 `json:"offset"`
	Limit      int32 `json:"limit"`
}

type ListCustomerLoansRow struct {
	ID                  int64          `json:"id"`
	CustomerID          int64          `json:"customer_id"`
	Description         string         `json:"description"`
	Amount              pgtype.Numeric `json:"amount"`
	CreatedAt           time.Time      `json:"created_at"`
	CustomerName        string         `json:"customer_name"`
	CustomerPhoneNumber string         `json:"customer_phone_number"`
}

func (q *Queries) ListCustomerLoans(ctx context.Context, arg ListCustomerLoansParams) ([]ListCustomerLoansRow, error) {
	rows, err := q.db.Query(ctx, listCustomerLoans, arg.CustomerID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCustomerLoansRow{}
	for rows.Next() {
		var i ListCustomerLoansRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Description,
			&i.Amount,
			&i.CreatedAt,
			&i.CustomerName,
			&i.CustomerPhoneNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLoans = `-- name: ListLoans :many
SELECT 
  loans.id, loans.customer_id, loans.description, loans.amount, loans.created_at, 
  customers.name AS customer_name, 
  customers.phone_number AS customer_phone_number
FROM loans
JOIN customers ON customers.id = loans.customer_id
ORDER BY loans.created_at DESC
LIMIT $2 OFFSET $1
`

type ListLoansParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

type ListLoansRow struct {
	ID                  int64          `json:"id"`
	CustomerID          int64          `json:"customer_id"`
	Description         string         `json:"description"`
	Amount              pgtype.Numeric `json:"amount"`
	CreatedAt           time.Time      `json:"created_at"`
	CustomerName        string         `json:"customer_name"`
	CustomerPhoneNumber string         `json:"customer_phone_number"`
}

func (q *Queries) ListLoans(ctx context.Context, arg ListLoansParams) ([]ListLoansRow, error) {
	rows, err := q.db.Query(ctx, listLoans, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLoansRow{}
	for rows.Next() {
		var i ListLoansRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Description,
			&i.Amount,
			&i.CreatedAt,
			&i.CustomerName,
			&i.CustomerPhoneNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

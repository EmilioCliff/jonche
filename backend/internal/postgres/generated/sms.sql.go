// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: sms.sql

package generated

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkSMSDelivered = `-- name: CheckSMSDelivered :one
SELECT 
  CASE 
    WHEN status = 'delivered' THEN TRUE 
    ELSE FALSE 
  END AS is_delivered
FROM sms
WHERE id = $1
`

func (q *Queries) CheckSMSDelivered(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRow(ctx, checkSMSDelivered, id)
	var is_delivered bool
	err := row.Scan(&is_delivered)
	return is_delivered, err
}

const countCustomerSMS = `-- name: CountCustomerSMS :one
SELECT COUNT(*) AS total_sms FROM sms WHERE customer_id = $1
`

func (q *Queries) CountCustomerSMS(ctx context.Context, customerID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countCustomerSMS, customerID)
	var total_sms int64
	err := row.Scan(&total_sms)
	return total_sms, err
}

const countSMS = `-- name: CountSMS :one
SELECT COUNT(*) AS total_sms FROM sms
`

func (q *Queries) CountSMS(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countSMS)
	var total_sms int64
	err := row.Scan(&total_sms)
	return total_sms, err
}

const createSMS = `-- name: CreateSMS :one
INSERT INTO sms (
    customer_id, message, type, ref_id
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, customer_id, message, type, status, created_at, ref_id, cost, description, callback_status
`

type CreateSMSParams struct {
	CustomerID int64  `json:"customer_id"`
	Message    string `json:"message"`
	Type       string `json:"type"`
	RefID      string `json:"ref_id"`
}

func (q *Queries) CreateSMS(ctx context.Context, arg CreateSMSParams) (Sm, error) {
	row := q.db.QueryRow(ctx, createSMS,
		arg.CustomerID,
		arg.Message,
		arg.Type,
		arg.RefID,
	)
	var i Sm
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Message,
		&i.Type,
		&i.Status,
		&i.CreatedAt,
		&i.RefID,
		&i.Cost,
		&i.Description,
		&i.CallbackStatus,
	)
	return i, err
}

const deliverSMS = `-- name: DeliverSMS :exec
UPDATE sms
SET status = $1
WHERE id = $2
`

type DeliverSMSParams struct {
	Status string `json:"status"`
	ID     int64  `json:"id"`
}

func (q *Queries) DeliverSMS(ctx context.Context, arg DeliverSMSParams) error {
	_, err := q.db.Exec(ctx, deliverSMS, arg.Status, arg.ID)
	return err
}

const getSMS = `-- name: GetSMS :one
SELECT
    sms.id, sms.customer_id, sms.message, sms.type, sms.status, sms.created_at, sms.ref_id, sms.cost, sms.description, sms.callback_status,
    customers.name AS customer_name, 
    customers.phone_number AS customer_phone_number
FROM sms
JOIN customers ON customers.id = sms.customer_id
WHERE sms.id = $1
ORDER BY sms.created_at DESC
`

type GetSMSRow struct {
	ID                  int64     `json:"id"`
	CustomerID          int64     `json:"customer_id"`
	Message             string    `json:"message"`
	Type                string    `json:"type"`
	Status              string    `json:"status"`
	CreatedAt           time.Time `json:"created_at"`
	RefID               string    `json:"ref_id"`
	Cost                string    `json:"cost"`
	Description         string    `json:"description"`
	CallbackStatus      string    `json:"callback_status"`
	CustomerName        string    `json:"customer_name"`
	CustomerPhoneNumber string    `json:"customer_phone_number"`
}

func (q *Queries) GetSMS(ctx context.Context, id int64) (GetSMSRow, error) {
	row := q.db.QueryRow(ctx, getSMS, id)
	var i GetSMSRow
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Message,
		&i.Type,
		&i.Status,
		&i.CreatedAt,
		&i.RefID,
		&i.Cost,
		&i.Description,
		&i.CallbackStatus,
		&i.CustomerName,
		&i.CustomerPhoneNumber,
	)
	return i, err
}

const listCustomerSMS = `-- name: ListCustomerSMS :many
SELECT 
  sms.id, sms.customer_id, sms.message, sms.type, sms.status, sms.created_at, sms.ref_id, sms.cost, sms.description, sms.callback_status, 
  customers.name AS customer_name, 
  customers.phone_number AS customer_phone_number
FROM sms
JOIN customers ON customers.id = sms.customer_id
WHERE sms.customer_id = $1
ORDER BY sms.created_at DESC
LIMIT $3 OFFSET $2
`

type ListCustomerSMSParams struct {
	CustomerID int64 `json:"customer_id"`
	Offset     int32 `json:"offset"`
	Limit      int32 `json:"limit"`
}

type ListCustomerSMSRow struct {
	ID                  int64     `json:"id"`
	CustomerID          int64     `json:"customer_id"`
	Message             string    `json:"message"`
	Type                string    `json:"type"`
	Status              string    `json:"status"`
	CreatedAt           time.Time `json:"created_at"`
	RefID               string    `json:"ref_id"`
	Cost                string    `json:"cost"`
	Description         string    `json:"description"`
	CallbackStatus      string    `json:"callback_status"`
	CustomerName        string    `json:"customer_name"`
	CustomerPhoneNumber string    `json:"customer_phone_number"`
}

func (q *Queries) ListCustomerSMS(ctx context.Context, arg ListCustomerSMSParams) ([]ListCustomerSMSRow, error) {
	rows, err := q.db.Query(ctx, listCustomerSMS, arg.CustomerID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCustomerSMSRow{}
	for rows.Next() {
		var i ListCustomerSMSRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Message,
			&i.Type,
			&i.Status,
			&i.CreatedAt,
			&i.RefID,
			&i.Cost,
			&i.Description,
			&i.CallbackStatus,
			&i.CustomerName,
			&i.CustomerPhoneNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSMS = `-- name: ListSMS :many
SELECT 
  sms.id, sms.customer_id, sms.message, sms.type, sms.status, sms.created_at, sms.ref_id, sms.cost, sms.description, sms.callback_status, 
  customers.name AS customer_name, 
  customers.phone_number AS customer_phone_number
FROM sms
JOIN customers ON customers.id = sms.customer_id
ORDER BY sms.created_at DESC
LIMIT $2 OFFSET $1
`

type ListSMSParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

type ListSMSRow struct {
	ID                  int64     `json:"id"`
	CustomerID          int64     `json:"customer_id"`
	Message             string    `json:"message"`
	Type                string    `json:"type"`
	Status              string    `json:"status"`
	CreatedAt           time.Time `json:"created_at"`
	RefID               string    `json:"ref_id"`
	Cost                string    `json:"cost"`
	Description         string    `json:"description"`
	CallbackStatus      string    `json:"callback_status"`
	CustomerName        string    `json:"customer_name"`
	CustomerPhoneNumber string    `json:"customer_phone_number"`
}

func (q *Queries) ListSMS(ctx context.Context, arg ListSMSParams) ([]ListSMSRow, error) {
	rows, err := q.db.Query(ctx, listSMS, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSMSRow{}
	for rows.Next() {
		var i ListSMSRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Message,
			&i.Type,
			&i.Status,
			&i.CreatedAt,
			&i.RefID,
			&i.Cost,
			&i.Description,
			&i.CallbackStatus,
			&i.CustomerName,
			&i.CustomerPhoneNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSMS = `-- name: UpdateSMS :exec
UPDATE sms
SET cost = coalesce($1, cost),
    description = coalesce($2, description),
    callback_status = coalesce($3, callback_status),
    status = coalesce($4, status)
WHERE ref_id = $5
`

type UpdateSMSParams struct {
	Cost           pgtype.Text `json:"cost"`
	Description    pgtype.Text `json:"description"`
	CallbackStatus pgtype.Text `json:"callback_status"`
	Status         pgtype.Text `json:"status"`
	RefID          string      `json:"ref_id"`
}

func (q *Queries) UpdateSMS(ctx context.Context, arg UpdateSMSParams) error {
	_, err := q.db.Exec(ctx, updateSMS,
		arg.Cost,
		arg.Description,
		arg.CallbackStatus,
		arg.Status,
		arg.RefID,
	)
	return err
}
